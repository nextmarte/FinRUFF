{"title":"Aula 2 -  Análise e otimização de carteiras","markdown":{"yaml":{"title":"Aula 2 -  Análise e otimização de carteiras","author":"Marcus Ramalho","language":{"title-block-author-single":"Professor: "}},"headingText":"Relembrando alguns conceitos sobre risco","containsRefs":false,"markdown":"\n\n\n**Risco**: Probabilidade de um resultado adverso em relação ao esperado.\n\n![](images/paste-2.png){width=\"718\"}\n\n## Tipos de risco\n\n-   **Risco conhecido**: Distribuição de probabilidade do evento é conhecida (ex: falha de motor).\n-   **Incerteza**: Distribuição de probabilidade desconhecida ou imprevisível (ex: crise econômica).\n\n## Atitudes frente ao risco\n\n-   **Aversão**: Prefere menor risco para mesmo retorno.\n-   **Indiferença**: Não se importa com o risco.\n-   **Propensão**: Aceita maior risco por potencial de maior retorno.\n\n![](images/paste-3.png){width=\"723\"}\n\nO participante de uma apólice de seguros têm que predisposição frente ao risco?\n\nE a companhia de seguros?\n\n## Mensuração do Risco\n\n-   **Desvio padrão (σ)**: Mede a dispersão dos resultados em torno da média.\n-   **Coeficiente de variação (CV)**: Mede o risco por unidade de retorno (σ / retorno médio).\n\n## Risco de Carteira\n\n-   **Covariância**: Mede a relação entre os retornos de dois ativos.\n-   **Diversificação**: Reduz o risco total da carteira ao combinar ativos com diferentes riscos (Markowitz, 1952) - \"Não colocar todos os ovos na mesma cesta\".\n\n## Risco individual vs. sistêmico\n\n-   **Individual**: Específico de cada ativo.\n-   **Sistêmico**: Afeta todo o mercado.\n\n## Índice Sharpe (IS)\n\n-   **Definição**: Mede o retorno adicional por unidade de risco em relação à taxa livre de risco.\n-   **Fórmula**: IS = (Retorno médio do portfólio - Taxa livre de risco) / Desvio padrão do excesso de retorno.\n-   **interpretação**: IS \\> 1: Retorno adicional por unidade de risco; IS \\< 1: Retorno insuficiente por unidade de risco. Quantos mais alto o índice, melhor.\n\n## Beta (β)\n\n-   **Definição**: Mede a sensibilidade do retorno de um ativo em relação ao retorno do mercado.\n-   **Fórmula**: β = Cov(Ri, Rm) / Var(Rm).\n-   **Interpretação**: β \\> 1: Ativo mais volátil que o mercado; β \\< 1: Ativo menos volátil que o mercado.\n-   **Exemplo**: Se β = 1, o ativo se move na mesma direção que o mercado.\n\n## Alfa (α)\n\n-   **Definição**: Mede o retorno adicional de um ativo em relação ao retorno esperado com base no risco.\n-   **Fórmula**: α = Retorno do ativo - (Taxa livre de risco + β \\* (Retorno do mercado - Taxa livre de risco)).\n-   **Interpretação**: α \\> 0: Ativo superou o retorno esperado; α \\< 0: Ativo ficou aquém do retorno esperado.\n-   **Exemplo**: Se α = 0, o ativo teve o retorno esperado com base no risco.\n-   **Observação**: O alfa é uma medida de desempenho ajustada ao risco.\n\n## Função de utilidade quadrática\n\nA função de utilidade quadrática é usada na otimização de portfólios para encontrar a alocação de ativos que maximiza o retorno esperado e minimiza o risco. A função de utilidade quadrática é dada por:\n\n$U = \\mu^T w - \\lambda \\sigma^2$\n\nonde:\n\n-   $U$ é a função de utilidade\n-   $\\mu^T$ é o vetor de retornos esperados\n-   $w$ é o vetor de pesos dos ativos\n-   $\\lambda$ é o fator de aversão ao risco\n\ngeneralizando para o caso de $n$ ativos, a função de utilidade quadrática é dada por:\n\n$U = \\mu^T w - \\lambda w^T \\Sigma w$\n\nonde:\n\n-   $\\Sigma w$ é a matriz de covariância dos retornos dos ativos\n-   $w^T$ é o vetor transposto de pesos dos ativos\n-   $w$ é o vetor de pesos dos ativos\n-   $\\lambda$ é o fator de aversão ao risco\n-   $\\mu$ é o vetor de retornos esperados\n-   $U$ é a função de utilidade\n\n## Otimização de portfólios\n\nA otimização de portfólios é um problema de maximização da função de utilidade quadrática sujeita a restrições, como a soma dos pesos dos ativos deve ser igual a 1 e os pesos dos ativos devem ser maiores ou iguais a zero.\n\n## Primeiro vamos carregar os pacotes necessários\n\n```{r}\n#| message: false\n#| warning: false\n#| error: false\n#| echo: false\n\n# Lista de pacotes necessários\npacotes <- c(\"tidyverse\", \"PortfolioAnalytics\", \"quantmod\", \"ROI\", \"ROI.plugin.quadprog\", \"ROI.plugin.glpk\",\"DEoptim\", \"timetk\", \"PerformanceAnalytics\")\n\n# Verifica se os pacotes estão instalados, instala os que faltam\nfor (pacote in pacotes) {\n  if (!require(pacote, character.only = TRUE)) {\n    install.packages(pacote)\n    library(pacote, character.only = TRUE)\n  }\n}\n\n```\n\n## Ativos selecionados\n\n```{r}\n\n# Ativos selecionados\n\ntickers <- c(\"VALE3.SA\",\"PETR4.SA\",\"AZUL4.SA\",\"MGLU3.SA\", \"CMIG4.SA\")\n\nprices <- \n  getSymbols(tickers, \n             src = 'yahoo', \n             from = \"2019-05-30\",\n             to = \"2024-05-30\",\n             auto.assign = TRUE, #obs auto asign carrega os resultados para o ambiente\n             warnings = FALSE,) %>% \n  map(~Ad(get(.))) %>% \n  reduce(merge) %>%\n  `colnames<-`(tickers)\n\n```\n\n## Baixando os preços do benchmark\n\n```{r}\n# Baixando os preços do IBOV\n\nibov <- getSymbols(\"^BVSP\", \n                   src = 'yahoo', \n                   from = \"2019-05-30\",\n                   to = \"2024-05-30\",\n                   auto.assign = TRUE, \n                   warnings = FALSE) %>% \n  map(~Ad(get(.))) %>% \n  reduce(merge) %>% \n  `colnames<-`(\"IBOV\")\n\nhead(ibov)\n\n```\n\n## Agora vamos converter os preços diários em mensais\n\n```{r}\n#| echo: true\n#| message: false\n\n\nprices_monthly <- to.monthly(prices, indexAt = \"lastof\", OHLC = FALSE)\nhead(prices_monthly)\n\nibov_monthly <- to.monthly(ibov, indexAt = \"lastof\", OHLC = FALSE)\nhead(ibov_monthly)\n```\n\n## Vamos calcular os retornos mensais\n\n```{r}\nasset_returns_xts <-\n PerformanceAnalytics::Return.calculate(prices_monthly, \n                   method = \"discrete\") %>% \n  na.omit()\n\nibov_returns_xts <- \n  PerformanceAnalytics::Return.calculate(ibov_monthly, \n                   method = \"discrete\") %>% \n  na.omit()\n\nhead(asset_returns_xts)\nhead(ibov_returns_xts)\n```\n\n## Otimização da carteira\n\n```{r}\n\n#| message: false\n\n# Criando o objeto de otimização\n\nportf <- portfolio.spec(assets = colnames(asset_returns_xts))\n\n# Adicionando restrições, como por exemplo, a soma dos pesos dos ativos deve ser igual a 1\n\nportf <- add.constraint(portf, type = \"full_investment\")\n\n# Adicionando restrição de peso mínimo e máximo para cada ativo\n# Neste caso, o peso mínimo é 0 e o peso máximo é 1\n\nportf <- add.constraint(portf, type = \"long_only\")\n\n\n# Adiciona a função objetivo, que é minimizar o desvio padrão da carteira\n\nportf <- add.objective(portf, type = \"risk\", name = \"StdDev\")\n\n# Resolve o problema de otimização\n\nopt_portf <- optimize.portfolio(asset_returns_xts, portf, optimize_method = \"ROI\")\n\n```\n\n## Resultados da otimização\n\n```{r}\n\nopt_portf\n\n```\n\n## Extraindo os pesos dos ativos\n\n```{r}\n\n\n# extraindo os pesos para um data frame\nweights <- extractWeights(opt_portf)\n\n# Adicionando os nomes dos ativos sem colocá-los no índice\nweights <- data.frame(tickers = colnames(asset_returns_xts), weights, row.names = NULL)\n\nweights\n\n\n\n\n```\n\n## plotando com o portfolioAnalytics\n\n```{r}\n\nchart.Weights(opt_portf)\n\n```\n\n## Plotando com ggplo2\n\n```{r}\n\nggplot(weights, aes(x = reorder(tickers, weights), y = weights, fill = tickers)) +\n  geom_col(color = \"black\", show.legend = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1),\n    plot.title = element_text(hjust = 0.5, size = 20, face = \"bold\"),\n    plot.subtitle = element_text(hjust = 0.5, size = 16),\n    legend.position = \"none\") +\n  scale_fill_viridis_d() +\n  labs(title = \"Distribuição dos Pesos dos Ativos\",\n   x = \"Ativos\",\n   y = \"Pesos\") +\n  coord_flip()\n\n```\n\n## Realizando otimização da função de utilidade com o PortfolioAnalytics\n\n```{r}\n\n#criar o objeto de otimização\n\nportf <- portfolio.spec(assets = colnames(asset_returns_xts))\n\n# Adicionando restrições, como por exemplo, a soma dos pesos dos ativos deve ser igual a 1\n\nportf <- add.constraint(portf, type = \"full_investment\")\n\n# Adicionando restrição de peso mínimo e máximo para cada ativo (0-1)\n\nportf <- add.constraint(portf, type = \"long_only\")\n\n# Adiciona a função objetivo, que é maximizar o retorno esperado\n\nportf <- add.objective(portf, type = \"return\", name = \"mean\")\n\n# Adiciona a função objetivo, que é minimizar a variância da carteira\n\nportf <- add.objective(portf, type = \"risk\", name = \"var\")\n\nportf <- add.objective(portf, type = \"quadratic_utility\", risk_aversion = 10)\n\n# Resolve o problema de otimização\n\nopt_portf <- optimize.portfolio(asset_returns_xts, portf, optimize_method = \"ROI\")\n\n# Extraindo os pesos dos ativos\n\nextractWeights(opt_portf)\n\n```\n\n## Pesos\n\n```{r}\n\n\nextractWeights(opt_portf)\n\n```\n\n## Entendendo a especificação do portfólio\n\nO objeto de portfólio é uma lista que contém as seguintes informações:\n\n-   **assets**: vetor de nomes dos ativos\n-   **constraints**: lista de restrições\n    -   **weight_sum**: restrição de que a soma dos pesos dos ativos deve ser igual a um valor específico\n    -   **full_investment**: restrição de que a soma dos pesos dos ativos deve ser igual a 1\n    -   **dollar_neutral**: restrição de que a soma dos pesos dos ativos deve ser igual a zero\n    -   **box**: restrição de que os pesos dos ativos devem estar dentro de um intervalo específico\n    -   **long_only**: restrição de que os pesos dos ativos devem ser maiores ou iguais a zero e menores ou iguais a um (caso especial da restrição box)\n    -   **group**: restrição de que os pesos dos ativos de um grupo específico devem ser iguais\n    -   **turnover**: restrição de que o turnover da carteira deve ser menor ou igual a um valor específico a partir de uma carteira inicial\n    -   **diversification**: Especifica um valor de diversificação para a carteira\n    -   **position_limit**: Permite ao usuário definir o número máximo de posições (ativos com pesos não nulos) e o número máximo de posições compradas e vendidas.\n    -   **return**: Especifica o retorno médio esperado da carteira\n    -   **factor_exposure**: Especifica a exposição da carteira a fatores de risco\n    -   **leverage_exposure**: Especifica a alavancagem maxima da carteira onde a alavancagem é definida como a soma dos pesos absolutos dos ativos\n-   **objectives**:\n    -   **type**: 'return','risk', 'risk_budget', 'quadratic_utility', or 'weight_concentration\n\n## Passo a passo da otimização de portfólios\n\n1.  Carregar os preços dos ativos e do benchmark\n2.  Converter os preços diários em preços mensais\n3.  Calcular os retornos mensais dos ativos e do benchmark\n4.  **Criar o objeto de portfólio**\n5.  **Adicionar restrições ao objeto de portfólio**\n6.  **Adicionar a função objetivo ao objeto de portfólio**\n7.  **Resolver o problema de otimização**\n8.  **Exibir os resultados da otimização**\n9.  **Exibir os pesos dos ativos na carteira otimizada**\n10. **Plotar a distribuição dos pesos dos ativos na carteira otimizada**\n\n## Criando um objeto para as especificações do portfólio\n\n```{r}\n\n# Criando o objeto de portfólio, aqui estamos apenas especificando os ativos que serão utilizados na otimização\n\nport_spec <- portfolio.spec(assets = colnames(asset_returns_xts))\n\nclass(port_spec)\n\n```\n\n## Adicionando restrições ao objeto de portfólio\n\nAs restrições são condições que devem ser satisfeitas durante a otimização da carteira. Algumas restrições comuns são relacionadas ao peso dos ativos e ao retorno esperado da carteira.\n\n```{r}\n\n# Adicionando restrições, como por exemplo, a soma dos pesos dos ativos deve ser igual a 1\n\nport_spec  <- add.constraint(port_spec, type = \"weight_sum\", min_sum = 1, max_sum = 1)\n\n# adicionnando uma restrição de caixas para os pesos dos ativos\n\nport_spec <- add.constraint(port_spec, type = \"box\", min = c(0.2, 0.1, 0.1, 0.1, 0.1), max = 0.4)\n\n\nport_spec\n\n\n```\n\n## Adicionando a função objetivo ao objeto de portfólio\n\nA função objetivo é a função que será otimizada durante o processo de otimização da carteira. Um objetivo comum é maximizar o retorno esperado da carteira e minimizar a volatilidade e o risco.\n\nLembre-se que o desvio padrão é a raiz quadrada da variância. E que a variância é a média dos quadrados dos desvios em relação à média. A variancia é geralmente usada para denotar o risco, quanto maior a variancia, maior o risco. Já geralmente denota a volatilidade, quanto maior o desvio padrão, maior a volatilidade. Ambas são medidas que servem como indicadores de risco.\n\nNo portfolioAnalytics, a função objetivo é adicionada ao objeto de portfólio usando a função `add.objective()`. Os objetivos mais usado são:\n\n-   **return**: Maximizar o retorno esperado da carteira\n-   **risk**: Minimizar o risco da carteira\n-   **risk_budget**: Minimizar a contribuição marginal do risco de cada ativo para o risco total da carteira\n-   **quadratic_utility**: Maximizar a função de utilidade quadrática da carteira\n-   **weight_concentration**: Minimizar a concentração dos pesos dos ativos na carteira\n\n```{r}\n\n# Adiciona a função objetivo, que é maximizar o retorno médio esperado da carteira\n\nport_spec <- add.objective(port_spec, type = \"return\", name = \"mean\")\n\n# Adiciona a função objetivo, que é minimizar o desvio padrão da carteira\n\nport_spec <- add.objective(port_spec, type = \"risk\", name = \"StdDev\")\n\n# Adiciona um objetivo para minimizar a contribuição marginal do risco de cada ativo para o risco total da carteira\n\nport_spec <- add.objective(port_spec, type = \"risk_budget\", name = \"var\", min_prisk = 0.05, max_prisk = 0.1)\n\nprint(port_spec)\n\n```\n\n## Resolvendo o problema de otimização\n\nExistem duas funções principais para resolver o problema de otimização da carteira: `optimize.portfolio()` e `optimize.portfolio.rebalancing()`. A função `optimize.portfolio()` é usada para otimizar a carteira sem rebalanceamento, enquanto a função `optimize.portfolio.rebalancing()` é usada para otimizar a carteira com rebalanceamento.\n\nLembre-se que o rebalanceamento é o processo de ajustar os pesos dos ativos na carteira para manter a alocação desejada ao longo do tempo.\n\nO pacote suporta diversos métodos de otimização, como:\n\n-   **DEoptim**: Differential Evolution\n-   **random**: Random Portfolios\n-   **GenSA**: Generalized Simulated Annealing\n-   **pso**: Particle Swarm Optimization\n-   **ROI**: R Optimization Infrastructure\n\nO método a ser usado irá depender do problema.\n\nVamos fazer fazer uma otimização usando o método de portifolios aleatórios. Nosso objetivo é maximizar o retorno esperado da carteira e minimizar o risco onde o risco minimo é 5% e o risco maximo é 10% sujeito a restrições de peso e de grupo.\n\n```{r}\n# .storage <<- new.env()\n\nrp <- random_portfolios(port_spec, permutations = 1000, rp_method = 'simplex')\n# rp <- random_portfolios(port_spec, permutations = 1000, rp_method = 'sample')\n# rp <- random_portfolios(port_spec, permutations = 1000, rp_method = 'grid') \n\nhead(rp)\n```\n\nSimplex: Distribui pesos aleatoriamente em um espaço triangular, garantindo que a soma seja sempre 1. Sample: Seleciona pesos aleatórios de uma distribuição de probabilidade específica. Grid: Gera pesos em pontos pré-definidos de uma grade regular.\n\n```{r}\nopt  <-  optimize.portfolio(R = asset_returns_xts, port_spec, rp = rp, optimize_method = \"random\", trace = TRUE)\n\nprint(opt)\n```\n\n## Otimizando a carteira com rebalanceamento\n\nA função `optimize.portfolio.rebalancing()` é usada para otimizar a carteira com rebalanceamento. O rebalanceamento é o processo de ajustar os pesos dos ativos na carteira para manter a alocação desejada ao longo do tempo. O rebalanceamento é importante para garantir que a carteira permaneça alinhada com os objetivos de investimento (restrições e objetivos) ao longo do tempo.\n\n`optimize.portfolio.rebalancing()` suporta otimização de carteiras com rebalanceamento em diferentes janelas de tempo. O backtest é o processo de testar uma estratégia de investimento em dados históricos para avaliar seu desempenho.\n\nOBS: Dependendo do método de otimização, o processo pode ser demorado.\n\nExemplo de otimização com rebalanceamento:\n\n```{r}\n\n# Criar o objeto de portfólio\nport_specr <- portfolio.spec(assets = colnames(asset_returns_xts))\n\n# Adicionar restrições - full investment com soma de pesos igual a 1\n\nport_specr <- add.constraint(port_specr, type = \"long_only\")\n\n# restrição para a soma dos pesos\n\nport_specr <- add.constraint(port_specr, type = \"weight_sum\", min_sum = 0.99, max_sum = 1.01)\n\n# Adicionar a função objetivo - maximizar o retorno esperado\n\nport_specr <- add.objective(port_specr, type = \"return\", name = \"mean\")\n\n# Adicionar a função objetivo - minimizar o risco\n\nport_specr <- add.objective(port_specr, type = \"risk\", name = \"StdDev\")\n\n# Adicionar a função objetivo - minimizar a contribuição marginal do risco de cada ativo para o risco total da carteira\n\nport_specr <- add.objective(port_specr, type = \"risk_budget\", name = \"StdDev\", min_prisk = 0.05, max_prisk = 0.1)\n\nrp <- random_portfolios(port_specr, permutations = 50, rp_method = 'simplex')\n\n```\n\n## Otimização\n\n```{r}\n\n# Otimização com rebalanceamento mensal\n\nopt_rebal <- optimize.portfolio.rebalancing(R = asset_returns_xts, \n                      portfolio = port_specr, \n                      optimize_method = \"random\",\n                      rp = rp,\n                      trace = TRUE,\n                      search_size = 1000,\n                      rebalance_on = \"months\",\n                      training_period = 12,\n                      rolling_window = 12)\n\nprint(opt_rebal)\n\n```\n\n## Analise dos resultados\n\n```{r}\n\nextractObjectiveMeasures(opt_rebal) |> head(1)\n\nextractWeights(opt_rebal) |> head()\n\nchart.Weights(opt) \n\nchart.Weights(opt_rebal)\n\n```\n\n## Plotando os pesos ao longo do tempo com ggplot2\n\n```{r}\n\n# Extraindo os pesos dos ativos ao longo do tempo\n\nweights_xts <- extractWeights(opt_rebal)\n\n# Convertendo os pesos para um data frame\n\nweights_df <- weights_xts %>% \n              tk_tbl(preserve_index = TRUE, rename_index = \"Date\")\n\n\n# Colocando o data frame em formato longo\n\nweights_long_df <- weights_df %>% \n                pivot_longer(cols = -Date, names_to = \"Asset\", values_to = \"Weight\")\n\n\nplotly::ggplotly(ggplot(weights_long_df) +\n  aes(x = Date, y = Weight, colour = Asset) +\n  geom_smooth(se = FALSE ) +\n  scale_fill_hue(direction = 1) +\n  labs(\n    x = \"Data\",\n    y = \"Peso\",\n    title = \"Peso dos ativos rebalanceados ao longo do tempo\",\n    colour = \"Ativos\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16L,\n    face = \"bold\",\n    hjust = 0.5)\n  )\n)\n\n```\n\n## Plotando o retorno do portfólio ao longo do tempo\n\n```{r}\n# Calculando o retorno do portfólio otimizado e adicionando o retorno do IBOV\nopt_returns_long_df <- Return.portfolio(R = asset_returns_xts, weights = extractWeights(opt_rebal)) %>%\n  tk_tbl(preserve_index = TRUE, rename_index = \"Date\") %>%\n  inner_join(ibov_returns_xts %>% tk_tbl(preserve_index = TRUE, rename_index = \"Date\"), by = \"Date\", suffix = c(\"_Portfolio\", \"_IBOV\")) %>%\n  pivot_longer(cols = -Date, names_to = \"Portfolio\", values_to = \"Return\")\n\nplotly::ggplotly(ggplot(opt_returns_long_df) +\n  aes(x = Date, y = Return, colour = Portfolio) +\n  geom_line() +\n  scale_fill_hue(direction = 1) +\n  labs(\n    x = \"Data\",\n    y = \"Retorno\",\n    title = \"Retorno do portifólio vs IBOV ao longo do tempo\",\n    colour = \"Portfólio\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16L,\n    face = \"bold\",\n    hjust = 0.5)\n  )\n)\n```\n\n## Bonus: Plotando a fronteira eficiente \n\nA fronteira eficiente é uma curva que mostra a combinação ótima de ativos em uma carteira que maximiza o retorno esperado para um determinado nível de risco. Note que o indice de Sharpe é a inclinação da linha tangente a fronteira eficiente, o intercepto com o eixo y é o retorno livre de risco e o ponto de tangência é o ponto com o maior indice de Sharpe.\n\n```{r}\n\n# Calculando a fronteira eficiente\nfrontier <- create.EfficientFrontier(R = asset_returns_xts, portfolio = port_spec, type = \"mean-StdDev\")\n\n# Plotando a fronteira eficiente\nchart.EfficientFrontier(frontier, match.col = \"StdDev\",n.portfolios = 30, main = \"Fronteira eficiente\")\n\n\n\n```\n\n\n\n## Dashboards interativos com QUARTO\n\n[Clique aqui!!](https://quarto.org/docs/dashboards/)\n\n## Exercício\n\n-   Crie uma carteira com 5 ativos de sua escolha\n-   Baixe os preços dos ativos\n-   Calcule os retornos mensais\n-   Crie um vetor de pesos para a carteira\n-   Calcule o retorno da carteira\n-   Faça a otimização da carteira com o objetivo de maximizar o retorno esperado e minimizar o risco\n-   Opcionalmente faça a otimização com rebalanceamento\n-   Visualize o retorno da carteira e dos ativos\n-   Compare o retorno da carteira com o índice do mercado\n-   Salve o seu dashboard e compartilhe com o professor\n\n## Dica: Use o arquivo das aulas anteriores como referência para criar o seu dashboard","srcMarkdownNoYaml":"\n\n## Relembrando alguns conceitos sobre risco\n\n**Risco**: Probabilidade de um resultado adverso em relação ao esperado.\n\n![](images/paste-2.png){width=\"718\"}\n\n## Tipos de risco\n\n-   **Risco conhecido**: Distribuição de probabilidade do evento é conhecida (ex: falha de motor).\n-   **Incerteza**: Distribuição de probabilidade desconhecida ou imprevisível (ex: crise econômica).\n\n## Atitudes frente ao risco\n\n-   **Aversão**: Prefere menor risco para mesmo retorno.\n-   **Indiferença**: Não se importa com o risco.\n-   **Propensão**: Aceita maior risco por potencial de maior retorno.\n\n![](images/paste-3.png){width=\"723\"}\n\nO participante de uma apólice de seguros têm que predisposição frente ao risco?\n\nE a companhia de seguros?\n\n## Mensuração do Risco\n\n-   **Desvio padrão (σ)**: Mede a dispersão dos resultados em torno da média.\n-   **Coeficiente de variação (CV)**: Mede o risco por unidade de retorno (σ / retorno médio).\n\n## Risco de Carteira\n\n-   **Covariância**: Mede a relação entre os retornos de dois ativos.\n-   **Diversificação**: Reduz o risco total da carteira ao combinar ativos com diferentes riscos (Markowitz, 1952) - \"Não colocar todos os ovos na mesma cesta\".\n\n## Risco individual vs. sistêmico\n\n-   **Individual**: Específico de cada ativo.\n-   **Sistêmico**: Afeta todo o mercado.\n\n## Índice Sharpe (IS)\n\n-   **Definição**: Mede o retorno adicional por unidade de risco em relação à taxa livre de risco.\n-   **Fórmula**: IS = (Retorno médio do portfólio - Taxa livre de risco) / Desvio padrão do excesso de retorno.\n-   **interpretação**: IS \\> 1: Retorno adicional por unidade de risco; IS \\< 1: Retorno insuficiente por unidade de risco. Quantos mais alto o índice, melhor.\n\n## Beta (β)\n\n-   **Definição**: Mede a sensibilidade do retorno de um ativo em relação ao retorno do mercado.\n-   **Fórmula**: β = Cov(Ri, Rm) / Var(Rm).\n-   **Interpretação**: β \\> 1: Ativo mais volátil que o mercado; β \\< 1: Ativo menos volátil que o mercado.\n-   **Exemplo**: Se β = 1, o ativo se move na mesma direção que o mercado.\n\n## Alfa (α)\n\n-   **Definição**: Mede o retorno adicional de um ativo em relação ao retorno esperado com base no risco.\n-   **Fórmula**: α = Retorno do ativo - (Taxa livre de risco + β \\* (Retorno do mercado - Taxa livre de risco)).\n-   **Interpretação**: α \\> 0: Ativo superou o retorno esperado; α \\< 0: Ativo ficou aquém do retorno esperado.\n-   **Exemplo**: Se α = 0, o ativo teve o retorno esperado com base no risco.\n-   **Observação**: O alfa é uma medida de desempenho ajustada ao risco.\n\n## Função de utilidade quadrática\n\nA função de utilidade quadrática é usada na otimização de portfólios para encontrar a alocação de ativos que maximiza o retorno esperado e minimiza o risco. A função de utilidade quadrática é dada por:\n\n$U = \\mu^T w - \\lambda \\sigma^2$\n\nonde:\n\n-   $U$ é a função de utilidade\n-   $\\mu^T$ é o vetor de retornos esperados\n-   $w$ é o vetor de pesos dos ativos\n-   $\\lambda$ é o fator de aversão ao risco\n\ngeneralizando para o caso de $n$ ativos, a função de utilidade quadrática é dada por:\n\n$U = \\mu^T w - \\lambda w^T \\Sigma w$\n\nonde:\n\n-   $\\Sigma w$ é a matriz de covariância dos retornos dos ativos\n-   $w^T$ é o vetor transposto de pesos dos ativos\n-   $w$ é o vetor de pesos dos ativos\n-   $\\lambda$ é o fator de aversão ao risco\n-   $\\mu$ é o vetor de retornos esperados\n-   $U$ é a função de utilidade\n\n## Otimização de portfólios\n\nA otimização de portfólios é um problema de maximização da função de utilidade quadrática sujeita a restrições, como a soma dos pesos dos ativos deve ser igual a 1 e os pesos dos ativos devem ser maiores ou iguais a zero.\n\n## Primeiro vamos carregar os pacotes necessários\n\n```{r}\n#| message: false\n#| warning: false\n#| error: false\n#| echo: false\n\n# Lista de pacotes necessários\npacotes <- c(\"tidyverse\", \"PortfolioAnalytics\", \"quantmod\", \"ROI\", \"ROI.plugin.quadprog\", \"ROI.plugin.glpk\",\"DEoptim\", \"timetk\", \"PerformanceAnalytics\")\n\n# Verifica se os pacotes estão instalados, instala os que faltam\nfor (pacote in pacotes) {\n  if (!require(pacote, character.only = TRUE)) {\n    install.packages(pacote)\n    library(pacote, character.only = TRUE)\n  }\n}\n\n```\n\n## Ativos selecionados\n\n```{r}\n\n# Ativos selecionados\n\ntickers <- c(\"VALE3.SA\",\"PETR4.SA\",\"AZUL4.SA\",\"MGLU3.SA\", \"CMIG4.SA\")\n\nprices <- \n  getSymbols(tickers, \n             src = 'yahoo', \n             from = \"2019-05-30\",\n             to = \"2024-05-30\",\n             auto.assign = TRUE, #obs auto asign carrega os resultados para o ambiente\n             warnings = FALSE,) %>% \n  map(~Ad(get(.))) %>% \n  reduce(merge) %>%\n  `colnames<-`(tickers)\n\n```\n\n## Baixando os preços do benchmark\n\n```{r}\n# Baixando os preços do IBOV\n\nibov <- getSymbols(\"^BVSP\", \n                   src = 'yahoo', \n                   from = \"2019-05-30\",\n                   to = \"2024-05-30\",\n                   auto.assign = TRUE, \n                   warnings = FALSE) %>% \n  map(~Ad(get(.))) %>% \n  reduce(merge) %>% \n  `colnames<-`(\"IBOV\")\n\nhead(ibov)\n\n```\n\n## Agora vamos converter os preços diários em mensais\n\n```{r}\n#| echo: true\n#| message: false\n\n\nprices_monthly <- to.monthly(prices, indexAt = \"lastof\", OHLC = FALSE)\nhead(prices_monthly)\n\nibov_monthly <- to.monthly(ibov, indexAt = \"lastof\", OHLC = FALSE)\nhead(ibov_monthly)\n```\n\n## Vamos calcular os retornos mensais\n\n```{r}\nasset_returns_xts <-\n PerformanceAnalytics::Return.calculate(prices_monthly, \n                   method = \"discrete\") %>% \n  na.omit()\n\nibov_returns_xts <- \n  PerformanceAnalytics::Return.calculate(ibov_monthly, \n                   method = \"discrete\") %>% \n  na.omit()\n\nhead(asset_returns_xts)\nhead(ibov_returns_xts)\n```\n\n## Otimização da carteira\n\n```{r}\n\n#| message: false\n\n# Criando o objeto de otimização\n\nportf <- portfolio.spec(assets = colnames(asset_returns_xts))\n\n# Adicionando restrições, como por exemplo, a soma dos pesos dos ativos deve ser igual a 1\n\nportf <- add.constraint(portf, type = \"full_investment\")\n\n# Adicionando restrição de peso mínimo e máximo para cada ativo\n# Neste caso, o peso mínimo é 0 e o peso máximo é 1\n\nportf <- add.constraint(portf, type = \"long_only\")\n\n\n# Adiciona a função objetivo, que é minimizar o desvio padrão da carteira\n\nportf <- add.objective(portf, type = \"risk\", name = \"StdDev\")\n\n# Resolve o problema de otimização\n\nopt_portf <- optimize.portfolio(asset_returns_xts, portf, optimize_method = \"ROI\")\n\n```\n\n## Resultados da otimização\n\n```{r}\n\nopt_portf\n\n```\n\n## Extraindo os pesos dos ativos\n\n```{r}\n\n\n# extraindo os pesos para um data frame\nweights <- extractWeights(opt_portf)\n\n# Adicionando os nomes dos ativos sem colocá-los no índice\nweights <- data.frame(tickers = colnames(asset_returns_xts), weights, row.names = NULL)\n\nweights\n\n\n\n\n```\n\n## plotando com o portfolioAnalytics\n\n```{r}\n\nchart.Weights(opt_portf)\n\n```\n\n## Plotando com ggplo2\n\n```{r}\n\nggplot(weights, aes(x = reorder(tickers, weights), y = weights, fill = tickers)) +\n  geom_col(color = \"black\", show.legend = FALSE) +\n  theme_minimal(base_size = 14) +\n  theme(axis.text.x = element_text(angle = 90, hjust = 1),\n    plot.title = element_text(hjust = 0.5, size = 20, face = \"bold\"),\n    plot.subtitle = element_text(hjust = 0.5, size = 16),\n    legend.position = \"none\") +\n  scale_fill_viridis_d() +\n  labs(title = \"Distribuição dos Pesos dos Ativos\",\n   x = \"Ativos\",\n   y = \"Pesos\") +\n  coord_flip()\n\n```\n\n## Realizando otimização da função de utilidade com o PortfolioAnalytics\n\n```{r}\n\n#criar o objeto de otimização\n\nportf <- portfolio.spec(assets = colnames(asset_returns_xts))\n\n# Adicionando restrições, como por exemplo, a soma dos pesos dos ativos deve ser igual a 1\n\nportf <- add.constraint(portf, type = \"full_investment\")\n\n# Adicionando restrição de peso mínimo e máximo para cada ativo (0-1)\n\nportf <- add.constraint(portf, type = \"long_only\")\n\n# Adiciona a função objetivo, que é maximizar o retorno esperado\n\nportf <- add.objective(portf, type = \"return\", name = \"mean\")\n\n# Adiciona a função objetivo, que é minimizar a variância da carteira\n\nportf <- add.objective(portf, type = \"risk\", name = \"var\")\n\nportf <- add.objective(portf, type = \"quadratic_utility\", risk_aversion = 10)\n\n# Resolve o problema de otimização\n\nopt_portf <- optimize.portfolio(asset_returns_xts, portf, optimize_method = \"ROI\")\n\n# Extraindo os pesos dos ativos\n\nextractWeights(opt_portf)\n\n```\n\n## Pesos\n\n```{r}\n\n\nextractWeights(opt_portf)\n\n```\n\n## Entendendo a especificação do portfólio\n\nO objeto de portfólio é uma lista que contém as seguintes informações:\n\n-   **assets**: vetor de nomes dos ativos\n-   **constraints**: lista de restrições\n    -   **weight_sum**: restrição de que a soma dos pesos dos ativos deve ser igual a um valor específico\n    -   **full_investment**: restrição de que a soma dos pesos dos ativos deve ser igual a 1\n    -   **dollar_neutral**: restrição de que a soma dos pesos dos ativos deve ser igual a zero\n    -   **box**: restrição de que os pesos dos ativos devem estar dentro de um intervalo específico\n    -   **long_only**: restrição de que os pesos dos ativos devem ser maiores ou iguais a zero e menores ou iguais a um (caso especial da restrição box)\n    -   **group**: restrição de que os pesos dos ativos de um grupo específico devem ser iguais\n    -   **turnover**: restrição de que o turnover da carteira deve ser menor ou igual a um valor específico a partir de uma carteira inicial\n    -   **diversification**: Especifica um valor de diversificação para a carteira\n    -   **position_limit**: Permite ao usuário definir o número máximo de posições (ativos com pesos não nulos) e o número máximo de posições compradas e vendidas.\n    -   **return**: Especifica o retorno médio esperado da carteira\n    -   **factor_exposure**: Especifica a exposição da carteira a fatores de risco\n    -   **leverage_exposure**: Especifica a alavancagem maxima da carteira onde a alavancagem é definida como a soma dos pesos absolutos dos ativos\n-   **objectives**:\n    -   **type**: 'return','risk', 'risk_budget', 'quadratic_utility', or 'weight_concentration\n\n## Passo a passo da otimização de portfólios\n\n1.  Carregar os preços dos ativos e do benchmark\n2.  Converter os preços diários em preços mensais\n3.  Calcular os retornos mensais dos ativos e do benchmark\n4.  **Criar o objeto de portfólio**\n5.  **Adicionar restrições ao objeto de portfólio**\n6.  **Adicionar a função objetivo ao objeto de portfólio**\n7.  **Resolver o problema de otimização**\n8.  **Exibir os resultados da otimização**\n9.  **Exibir os pesos dos ativos na carteira otimizada**\n10. **Plotar a distribuição dos pesos dos ativos na carteira otimizada**\n\n## Criando um objeto para as especificações do portfólio\n\n```{r}\n\n# Criando o objeto de portfólio, aqui estamos apenas especificando os ativos que serão utilizados na otimização\n\nport_spec <- portfolio.spec(assets = colnames(asset_returns_xts))\n\nclass(port_spec)\n\n```\n\n## Adicionando restrições ao objeto de portfólio\n\nAs restrições são condições que devem ser satisfeitas durante a otimização da carteira. Algumas restrições comuns são relacionadas ao peso dos ativos e ao retorno esperado da carteira.\n\n```{r}\n\n# Adicionando restrições, como por exemplo, a soma dos pesos dos ativos deve ser igual a 1\n\nport_spec  <- add.constraint(port_spec, type = \"weight_sum\", min_sum = 1, max_sum = 1)\n\n# adicionnando uma restrição de caixas para os pesos dos ativos\n\nport_spec <- add.constraint(port_spec, type = \"box\", min = c(0.2, 0.1, 0.1, 0.1, 0.1), max = 0.4)\n\n\nport_spec\n\n\n```\n\n## Adicionando a função objetivo ao objeto de portfólio\n\nA função objetivo é a função que será otimizada durante o processo de otimização da carteira. Um objetivo comum é maximizar o retorno esperado da carteira e minimizar a volatilidade e o risco.\n\nLembre-se que o desvio padrão é a raiz quadrada da variância. E que a variância é a média dos quadrados dos desvios em relação à média. A variancia é geralmente usada para denotar o risco, quanto maior a variancia, maior o risco. Já geralmente denota a volatilidade, quanto maior o desvio padrão, maior a volatilidade. Ambas são medidas que servem como indicadores de risco.\n\nNo portfolioAnalytics, a função objetivo é adicionada ao objeto de portfólio usando a função `add.objective()`. Os objetivos mais usado são:\n\n-   **return**: Maximizar o retorno esperado da carteira\n-   **risk**: Minimizar o risco da carteira\n-   **risk_budget**: Minimizar a contribuição marginal do risco de cada ativo para o risco total da carteira\n-   **quadratic_utility**: Maximizar a função de utilidade quadrática da carteira\n-   **weight_concentration**: Minimizar a concentração dos pesos dos ativos na carteira\n\n```{r}\n\n# Adiciona a função objetivo, que é maximizar o retorno médio esperado da carteira\n\nport_spec <- add.objective(port_spec, type = \"return\", name = \"mean\")\n\n# Adiciona a função objetivo, que é minimizar o desvio padrão da carteira\n\nport_spec <- add.objective(port_spec, type = \"risk\", name = \"StdDev\")\n\n# Adiciona um objetivo para minimizar a contribuição marginal do risco de cada ativo para o risco total da carteira\n\nport_spec <- add.objective(port_spec, type = \"risk_budget\", name = \"var\", min_prisk = 0.05, max_prisk = 0.1)\n\nprint(port_spec)\n\n```\n\n## Resolvendo o problema de otimização\n\nExistem duas funções principais para resolver o problema de otimização da carteira: `optimize.portfolio()` e `optimize.portfolio.rebalancing()`. A função `optimize.portfolio()` é usada para otimizar a carteira sem rebalanceamento, enquanto a função `optimize.portfolio.rebalancing()` é usada para otimizar a carteira com rebalanceamento.\n\nLembre-se que o rebalanceamento é o processo de ajustar os pesos dos ativos na carteira para manter a alocação desejada ao longo do tempo.\n\nO pacote suporta diversos métodos de otimização, como:\n\n-   **DEoptim**: Differential Evolution\n-   **random**: Random Portfolios\n-   **GenSA**: Generalized Simulated Annealing\n-   **pso**: Particle Swarm Optimization\n-   **ROI**: R Optimization Infrastructure\n\nO método a ser usado irá depender do problema.\n\nVamos fazer fazer uma otimização usando o método de portifolios aleatórios. Nosso objetivo é maximizar o retorno esperado da carteira e minimizar o risco onde o risco minimo é 5% e o risco maximo é 10% sujeito a restrições de peso e de grupo.\n\n```{r}\n# .storage <<- new.env()\n\nrp <- random_portfolios(port_spec, permutations = 1000, rp_method = 'simplex')\n# rp <- random_portfolios(port_spec, permutations = 1000, rp_method = 'sample')\n# rp <- random_portfolios(port_spec, permutations = 1000, rp_method = 'grid') \n\nhead(rp)\n```\n\nSimplex: Distribui pesos aleatoriamente em um espaço triangular, garantindo que a soma seja sempre 1. Sample: Seleciona pesos aleatórios de uma distribuição de probabilidade específica. Grid: Gera pesos em pontos pré-definidos de uma grade regular.\n\n```{r}\nopt  <-  optimize.portfolio(R = asset_returns_xts, port_spec, rp = rp, optimize_method = \"random\", trace = TRUE)\n\nprint(opt)\n```\n\n## Otimizando a carteira com rebalanceamento\n\nA função `optimize.portfolio.rebalancing()` é usada para otimizar a carteira com rebalanceamento. O rebalanceamento é o processo de ajustar os pesos dos ativos na carteira para manter a alocação desejada ao longo do tempo. O rebalanceamento é importante para garantir que a carteira permaneça alinhada com os objetivos de investimento (restrições e objetivos) ao longo do tempo.\n\n`optimize.portfolio.rebalancing()` suporta otimização de carteiras com rebalanceamento em diferentes janelas de tempo. O backtest é o processo de testar uma estratégia de investimento em dados históricos para avaliar seu desempenho.\n\nOBS: Dependendo do método de otimização, o processo pode ser demorado.\n\nExemplo de otimização com rebalanceamento:\n\n```{r}\n\n# Criar o objeto de portfólio\nport_specr <- portfolio.spec(assets = colnames(asset_returns_xts))\n\n# Adicionar restrições - full investment com soma de pesos igual a 1\n\nport_specr <- add.constraint(port_specr, type = \"long_only\")\n\n# restrição para a soma dos pesos\n\nport_specr <- add.constraint(port_specr, type = \"weight_sum\", min_sum = 0.99, max_sum = 1.01)\n\n# Adicionar a função objetivo - maximizar o retorno esperado\n\nport_specr <- add.objective(port_specr, type = \"return\", name = \"mean\")\n\n# Adicionar a função objetivo - minimizar o risco\n\nport_specr <- add.objective(port_specr, type = \"risk\", name = \"StdDev\")\n\n# Adicionar a função objetivo - minimizar a contribuição marginal do risco de cada ativo para o risco total da carteira\n\nport_specr <- add.objective(port_specr, type = \"risk_budget\", name = \"StdDev\", min_prisk = 0.05, max_prisk = 0.1)\n\nrp <- random_portfolios(port_specr, permutations = 50, rp_method = 'simplex')\n\n```\n\n## Otimização\n\n```{r}\n\n# Otimização com rebalanceamento mensal\n\nopt_rebal <- optimize.portfolio.rebalancing(R = asset_returns_xts, \n                      portfolio = port_specr, \n                      optimize_method = \"random\",\n                      rp = rp,\n                      trace = TRUE,\n                      search_size = 1000,\n                      rebalance_on = \"months\",\n                      training_period = 12,\n                      rolling_window = 12)\n\nprint(opt_rebal)\n\n```\n\n## Analise dos resultados\n\n```{r}\n\nextractObjectiveMeasures(opt_rebal) |> head(1)\n\nextractWeights(opt_rebal) |> head()\n\nchart.Weights(opt) \n\nchart.Weights(opt_rebal)\n\n```\n\n## Plotando os pesos ao longo do tempo com ggplot2\n\n```{r}\n\n# Extraindo os pesos dos ativos ao longo do tempo\n\nweights_xts <- extractWeights(opt_rebal)\n\n# Convertendo os pesos para um data frame\n\nweights_df <- weights_xts %>% \n              tk_tbl(preserve_index = TRUE, rename_index = \"Date\")\n\n\n# Colocando o data frame em formato longo\n\nweights_long_df <- weights_df %>% \n                pivot_longer(cols = -Date, names_to = \"Asset\", values_to = \"Weight\")\n\n\nplotly::ggplotly(ggplot(weights_long_df) +\n  aes(x = Date, y = Weight, colour = Asset) +\n  geom_smooth(se = FALSE ) +\n  scale_fill_hue(direction = 1) +\n  labs(\n    x = \"Data\",\n    y = \"Peso\",\n    title = \"Peso dos ativos rebalanceados ao longo do tempo\",\n    colour = \"Ativos\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16L,\n    face = \"bold\",\n    hjust = 0.5)\n  )\n)\n\n```\n\n## Plotando o retorno do portfólio ao longo do tempo\n\n```{r}\n# Calculando o retorno do portfólio otimizado e adicionando o retorno do IBOV\nopt_returns_long_df <- Return.portfolio(R = asset_returns_xts, weights = extractWeights(opt_rebal)) %>%\n  tk_tbl(preserve_index = TRUE, rename_index = \"Date\") %>%\n  inner_join(ibov_returns_xts %>% tk_tbl(preserve_index = TRUE, rename_index = \"Date\"), by = \"Date\", suffix = c(\"_Portfolio\", \"_IBOV\")) %>%\n  pivot_longer(cols = -Date, names_to = \"Portfolio\", values_to = \"Return\")\n\nplotly::ggplotly(ggplot(opt_returns_long_df) +\n  aes(x = Date, y = Return, colour = Portfolio) +\n  geom_line() +\n  scale_fill_hue(direction = 1) +\n  labs(\n    x = \"Data\",\n    y = \"Retorno\",\n    title = \"Retorno do portifólio vs IBOV ao longo do tempo\",\n    colour = \"Portfólio\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16L,\n    face = \"bold\",\n    hjust = 0.5)\n  )\n)\n```\n\n## Bonus: Plotando a fronteira eficiente \n\nA fronteira eficiente é uma curva que mostra a combinação ótima de ativos em uma carteira que maximiza o retorno esperado para um determinado nível de risco. Note que o indice de Sharpe é a inclinação da linha tangente a fronteira eficiente, o intercepto com o eixo y é o retorno livre de risco e o ponto de tangência é o ponto com o maior indice de Sharpe.\n\n```{r}\n\n# Calculando a fronteira eficiente\nfrontier <- create.EfficientFrontier(R = asset_returns_xts, portfolio = port_spec, type = \"mean-StdDev\")\n\n# Plotando a fronteira eficiente\nchart.EfficientFrontier(frontier, match.col = \"StdDev\",n.portfolios = 30, main = \"Fronteira eficiente\")\n\n\n\n```\n\n\n\n## Dashboards interativos com QUARTO\n\n[Clique aqui!!](https://quarto.org/docs/dashboards/)\n\n## Exercício\n\n-   Crie uma carteira com 5 ativos de sua escolha\n-   Baixe os preços dos ativos\n-   Calcule os retornos mensais\n-   Crie um vetor de pesos para a carteira\n-   Calcule o retorno da carteira\n-   Faça a otimização da carteira com o objetivo de maximizar o retorno esperado e minimizar o risco\n-   Opcionalmente faça a otimização com rebalanceamento\n-   Visualize o retorno da carteira e dos ativos\n-   Compare o retorno da carteira com o índice do mercado\n-   Salve o seu dashboard e compartilhe com o professor\n\n## Dica: Use o arquivo das aulas anteriores como referência para criar o seu dashboard"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"aula_2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Professor: ","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":{"light":"cosmos"},"title":"Aula 2 -  Análise e otimização de carteiras","author":"Marcus Ramalho"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}